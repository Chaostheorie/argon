import { AxiosResponse } from 'axios';
import { RpcClientOptions, RpcRequest, RpcResponse } from './interfaces';
declare type RpcBatchRequest<TMethod, TParams> = Array<RpcRequest<TMethod, TParams>>;
declare type RpcBatchResponse<TResponse, TError> = Array<RpcResponse<TResponse, TError>>;
declare type ReturnTypeOfMethod<T> = T extends (...args: Array<any>) => any ? ReturnType<T> : any;
declare type ReturnTypeOfMethodIfExists<T, S> = S extends keyof T ? ReturnTypeOfMethod<T[S]> : any;
declare type MethodParams<T> = T extends (...args: infer P) => any ? P[0] : T;
declare type MethodParamsIfExists<T, S> = S extends keyof T ? MethodParams<T[S]> : S;
export declare class RpcClient<TMethods = any> {
    private readonly options;
    private readonly client;
    constructor(options: RpcClientOptions);
    /**
     * Make JSON RPC Batch Request of the same method
     * @throws {AxiosError | RpcError} http/rpc error
     */
    makeBatchRequest<K extends keyof TMethods, TResponse = any, TError = any>(requests: RpcBatchRequest<K, TMethods[K]>): Promise<AxiosResponse<RpcBatchResponse<TResponse, TError>>>;
    /**
     * Make JSON RPC Request
     * @throws {AxiosError | RpcError} http/rpc error
     */
    makeRequest<K extends keyof TMethods, TError = any>(request: RpcRequest<K, MethodParamsIfExists<TMethods, K>>): Promise<AxiosResponse<RpcResponse<ReturnTypeOfMethodIfExists<TMethods, K>, TError>>>;
}
export {};
